import type { NormalizedField, IndexDefinition } from "../types";
import type { DDLStrategy } from "../interfaces/DDLStrategy";
import {
  getCanonicalBaseType,
  supportsAutoIncrement,
  supportsDefaultCurrentTimestamp,
  supportsUuidDefault,
  formatConstantDefault,
  shouldQuoteDefault,
  isLikelyFunctionOrKeyword,
  escapeSingleQuotes,
  splitQualifiedName,
  parseFieldType,
} from "../utils/databaseTypeMapping";
import { TypeMapper } from "../utils/TypeMapper";

export class PostgresStrategy implements DDLStrategy {
  getDatabaseType(): "postgresql" {
    return "postgresql";
  }

  formatTableName(tableName: string): string {
    const parts = splitQualifiedName(tableName);
    if (parts.length === 0) {
      return tableName.trim();
    }
    return parts.join(".");
  }

  formatFieldName(fieldName: string): string {
    return fieldName;
  }

  generateTableDDL(
    tableName: string,
    tableComment: string,
    fields: NormalizedField[]
  ): string {
    const typeMapper = TypeMapper.create("postgresql");
    const columnLines = fields.map((field) => {
      const parsedType = parseFieldType(field.type);
      const type = typeMapper.mapType(parsedType);
      const base = getCanonicalBaseType(field.type);

      const identity =
        field.defaultKind === "auto_increment" &&
        supportsAutoIncrement("postgresql", base)
          ? " GENERATED BY DEFAULT AS IDENTITY"
          : "";

      const nullableClause = field.nullable ? "" : " NOT NULL";

      let def = "";
      if (field.defaultKind === "constant") {
        def = formatConstantDefault(base, field.defaultValue);
      } else if (
        field.defaultKind === "current_timestamp" &&
        supportsDefaultCurrentTimestamp("postgresql", base)
      ) {
        def = " DEFAULT CURRENT_TIMESTAMP";
      } else if (field.defaultKind === "uuid" && supportsUuidDefault(base)) {
        def = " DEFAULT gen_random_uuid()";
      }

      return `  ${this.formatFieldName(
        field.name
      )} ${type}${identity}${nullableClause}${def}`;
    });

    const qualifiedTableName = this.formatTableName(tableName);
    const statements: string[] = [
      `CREATE TABLE ${qualifiedTableName} (\n${columnLines.join(",\n")}\n);`,
    ];

    if (tableComment.trim()) {
      statements.push(
        `COMMENT ON TABLE ${qualifiedTableName} IS '${escapeSingleQuotes(
          tableComment.trim()
        )}';`
      );
    }

    fields
      .filter((field) => field.comment)
      .forEach((field) => {
        statements.push(
          `COMMENT ON COLUMN ${qualifiedTableName}.${this.formatFieldName(
            field.name
          )} IS '${escapeSingleQuotes(field.comment)}';`
        );
      });

    return statements.join("\n");
  }

  generateIndexDDL(
    tableName: string,
    index: IndexDefinition,
    fields: NormalizedField[]
  ): string {
    // Skip primary keys as they are handled differently
    if (index.isPrimary) {
      const fieldList = index.fields.map((f) => f.name).join(", ");
      return `ALTER TABLE ${this.formatTableName(
        tableName
      )} ADD PRIMARY KEY (${fieldList});`;
    }

    const indexType = index.unique ? "UNIQUE INDEX" : "INDEX";
    const fieldList = index.fields
      .map((f) => `${f.name} ${f.direction}`)
      .join(", ");

    return `CREATE ${indexType} ${index.name} ON ${this.formatTableName(
      tableName
    )} (${fieldList});`;
  }
}